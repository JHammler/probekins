# probekins
http://wiki.linuxcnc.org/cgi-bin/wiki.pl?ProbeKins

Probekins: Z correction by probing the workpiece or machine surface
The probekins kins module is a trivkins module with optional Z correction. By default, probekins behaves like the trivkins module.

The purpose of probekins is to aid milling slightly warped workpiece surfaces, or deal with a machine imprecision, like for instance when milling a PCB when the board is not ideally horizontal after clamping, or slightly bent or warped. The idea is to probe the actual surface at several points covering the whole milling area, and generate Z correction values from the probed values by interpolating between neighbouring points.

Z corrections are applied when a Z correction mesh is loaded into probekins, and z correction is turned on by a HAL pin. Then the Z value of the programmed point is corrected by the Z value of the mesh at the given X/Y position.

A mesh consists of neighbouring triangles, which is normally generated automatically from a set of probed points, but could as well also be generated by hand. The probed points, or the workpiece for that matter, may be in arbitrary positions, i.e. need not be rectangular. The intended milling area should be covered by the probed points.

### typical work flow
*probe an area, or workpiece, repeatedly and record the probe results with (PROBEOPEN probe.txt) and (PROBECLOSE) .

*convert this file into a triangulated correction mesh with probe2stl

*load the correction mesh into the probekins shared memory segment with stlcorr.

*set the enable-z-correct HAL pin to 1

*touch off Z zero at an arbitrary point within the area covered by the probed points.

In G code:

 (PROBEOPEN probe.txt) 
  G38.2 X...
 ...
 (PROBECLOSE)
 $ probe2stl [-i inifile] <probe.txt |stlcorr --load
To activate Z correction:

 $ halcmd setp probekins.enable-z-correct 1
As long as probekins.enable-z-correct is zero, it behaves exactly like the trivkins module, and also incurs no runtime overhead.


## Internals
The correction mesh is a set of triangles specified by an STL file (see http://en.wikipedia.org/wiki/STL_%28file_format%29) . It is exposed by a HAL shared memory segment, and loaded by using the hal.shm() function.

Probe2stl creates a Delauney triangulation of the probe points, and outputs an STL file.

The advantage of using a mesh of triangles over a rectangular mesh lies in the aribtrary shape and density of probe points.

If a point (x,y) lies within the one of the triangles, it's z value is adjusted by the interpolated value on the enclosing triangle. Points outside any triangle are not corrected for. This means the correction value 'falls off the cliff' at the enclosing polygon.

The triangles are tested in the order specified in the file, so there could be a 'later' larger triangle enclosing or overlapping an earlier one.

The algorithm is based on a sequential test of all triangles until first match. The line/triangle intersection test is very fast (< 1 usec/triangle on my box), nevertheless this is an O(number of triangles) implementation. There are numerous ways to optimize this, like adding a kd-tree to speed up lookup of candidate triangles.

### WARNING
The above works 'in principle' BUT it needs serious testing, in particular:

I have observed strange results (erratic Z correction values) with moves along mesh boundaries. I have not dug into it deeply enough, but my gut feeling is this could be a numerical accuracy issue where a point on a boundary between triangles happens to match neither triangle and thus 'falls on the floor' (getting a zero Z correction value).

I am open to suggestions how this can be detected and fixed. One obvious way would be to enlarge the triangles by some epsilon value, to assure they overlap - in case this is the actual cause. A possible test strategy would be to test the number of triangle hits.

note this error can cause serious damage to a machine!
